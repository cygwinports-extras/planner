--- origsrc/planner-0.14.3/configure.in	2008-04-12 07:49:23.000000000 -0500
+++ src/planner-0.14.3/configure.in	2008-04-22 01:46:14.000000000 -0500
@@ -35,6 +35,25 @@
     enable_update_mimedb=yes)
 AM_CONDITIONAL(ENABLE_UPDATE_MIMEDB, test x$enable_update_mimedb = xyes)
 
+dnl  -------------
+dnl | Windows    |--------------------------------------------
+dnl  -------------
+case $host_os in
+  cygwin*|mingw*)
+	platform_win32=yes
+	PLUGIN_LDFLAGS="-module -avoid-version -no-undefined -Wl,\$(top_builddir)/src/libplanner-plugin.a \$(top_builddir)/libplanner/libplanner-1.la \$(PLANNER_LIBS)"
+	PLANNER_IMPLIB="-lplanner-plugin"
+	;;
+  *)
+	platform_win32=no
+	PLUGIN_LDFLAGS="-module -avoid-version"
+	PLANNER_IMPLIB=
+	;;
+esac
+AM_CONDITIONAL(PLATFORM_WIN32, test x$platform_win32 = xyes)
+AC_SUBST(PLUGIN_LDFLAGS)
+AC_SUBST(PLANNER_IMPLIB)
+dnl -----------------------------------------------------------
 
 dnl
 dnl GConf
--- origsrc/planner-0.14.3/eds-backend/Makefile.am	2007-11-14 16:22:22.000000000 -0600
+++ src/planner-0.14.3/eds-backend/Makefile.am	2008-04-22 01:34:39.562500000 -0500
@@ -16,3 +16,5 @@
 libecalbackendplanner_la_LIBADD =		 	\
 	$(top_builddir)/libplanner/libplanner-1.la 	\
 	$(EDS_BACKEND_LIBS)				
+
+libecalbackendplanner_la_LDFLAGS = -module -avoid-version -no-undefined
--- origsrc/planner-0.14.3/eds-backend/planner-source/Makefile.am	2007-11-14 16:22:22.000000000 -0600
+++ src/planner-0.14.3/eds-backend/planner-source/Makefile.am	2008-04-22 01:34:39.562500000 -0500
@@ -11,7 +11,7 @@
 
 
 liborg_gnome_planner_source_la_SOURCES = planner-source.c
-liborg_gnome_planner_source_la_LDFLAGS = -module -avoid-version
+liborg_gnome_planner_source_la_LDFLAGS = -module -avoid-version -no-undefined
 liborg_gnome_planner_source_la_LIBADD =	 $(EDS_BACKEND_LIBS)
 
 EXTRA_DIST = org-gnome-planner-source.eplug.in
--- origsrc/planner-0.14.3/libegg/recent-files/egg-recent-model.c	2007-11-14 16:22:20.000000000 -0600
+++ src/planner-0.14.3/libegg/recent-files/egg-recent-model.c	2008-04-22 01:34:39.578125000 -0500
@@ -1,5 +1,5 @@
 /* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
-/**
+/*
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as
  * published by the Free Software Foundation; either version 2 of the
@@ -29,6 +29,7 @@
 #include <unistd.h>
 #include <fcntl.h>
 #include <sys/time.h>
+#include <sys/stat.h>
 #include <time.h>
 #include <gtk/gtk.h>
 #include <libgnomevfs/gnome-vfs.h>
@@ -43,6 +44,12 @@
 #define EGG_RECENT_MODEL_MAX_ITEMS 500
 #define EGG_RECENT_MODEL_DEFAULT_LIMIT 10
 #define EGG_RECENT_MODEL_TIMEOUT_LENGTH 200
+#define EGG_RECENT_MODEL_POLL_TIME 3
+
+/* needed for Darwin */
+#if !HAVE_DECL_LOCKF
+int lockf (int filedes, int function, off_t size);
+#endif
 
 #define EGG_RECENT_MODEL_KEY_DIR "/desktop/gnome/recent_files"
 #define EGG_RECENT_MODEL_DEFAULT_LIMIT_KEY EGG_RECENT_MODEL_KEY_DIR "/default_limit"
@@ -71,6 +78,8 @@
 	guint expiration_change_notify_id;
 
 	guint changed_timeout;
+	guint poll_timeout;
+	time_t last_mtime;
 };
 
 /* signals */
@@ -95,7 +104,7 @@
 	GSList *states;
 	GList *items;
 	EggRecentItem *current_item;
-}ParseInfo;
+} ParseInfo;
 
 typedef enum {
 	STATE_START,
@@ -109,10 +118,10 @@
 	STATE_GROUP
 } ParseState;
 
-typedef struct _ChangedData {
+typedef struct {
 	EggRecentModel *model;
 	GList *list;
-}ChangedData;
+} ChangedData;
 
 #define TAG_RECENT_FILES "RecentFiles"
 #define TAG_RECENT_ITEM "RecentItem"
@@ -150,6 +159,14 @@
 			NULL,
 			error_handler};
 
+static GObjectClass *parent_class;
+
+static void egg_recent_model_clear_mime_filter (EggRecentModel *model);
+static void egg_recent_model_clear_group_filter (EggRecentModel *model);
+static void egg_recent_model_clear_scheme_filter (EggRecentModel *model);
+
+static GObjectClass *parent_class;
+
 static gboolean
 egg_recent_model_string_match (const GSList *list, const gchar *str)
 {
@@ -193,7 +210,9 @@
 	if (fputs (content, file) == EOF)
 		return FALSE;
 
+#ifndef G_OS_WIN32
 	fsync (fd);
+#endif
 	rewind (file);
 
 	return TRUE;
@@ -294,17 +313,23 @@
 
 
 
-static void
-parse_info_init (ParseInfo *info)
+static ParseInfo *
+parse_info_init (void)
 {
-	info->states = g_slist_prepend (NULL, STATE_START);
-	info->items = NULL;
+	ParseInfo *retval;
+	
+	retval = g_new0 (ParseInfo, 1);
+	retval->states = g_slist_prepend (NULL, STATE_START);
+	retval->items = NULL;
+	
+	return retval;
 }
 
 static void
 parse_info_free (ParseInfo *info)
 {
 	g_slist_free (info->states);
+	g_free (info);
 }
 
 static void
@@ -332,6 +357,25 @@
 
 #define ELEMENT_IS(name) (strcmp (element_name, (name)) == 0)
 
+static gboolean
+valid_element (ParseInfo    *info,
+	       int           valid_parent_state,
+	       const gchar  *element_name,
+	       const gchar  *valid_element,
+	       GError      **error)
+{
+	if (peek_state (info) != valid_parent_state) {
+	      g_set_error (error,
+			   G_MARKUP_ERROR,
+			   G_MARKUP_ERROR_INVALID_CONTENT,
+			   "Unexpected tag '%s', tag '%s' expected",
+			   element_name, valid_element);
+	      return FALSE;
+	}
+
+	return TRUE;
+}
+
 static void
 start_element_handler (GMarkupParseContext *context,
 			      const gchar *element_name,
@@ -345,21 +389,43 @@
 	if (ELEMENT_IS (TAG_RECENT_FILES))
 		push_state (info, STATE_RECENT_FILES);
 	else if (ELEMENT_IS (TAG_RECENT_ITEM)) {
-		info->current_item = egg_recent_item_new ();
-		push_state (info, STATE_RECENT_ITEM);
-	} else if (ELEMENT_IS (TAG_URI))
-		push_state (info, STATE_URI);
-	else if (ELEMENT_IS (TAG_MIME_TYPE))
-		push_state (info, STATE_MIME_TYPE);
-	else if (ELEMENT_IS (TAG_TIMESTAMP))
-		push_state (info, STATE_TIMESTAMP);
-	else if (ELEMENT_IS (TAG_PRIVATE)) {
-		push_state (info, STATE_PRIVATE);
-		egg_recent_item_set_private (info->current_item, TRUE);
-	} else if (ELEMENT_IS (TAG_GROUPS))
-		push_state (info, STATE_GROUPS);
-	else if (ELEMENT_IS (TAG_GROUP)) 
-		push_state (info, STATE_GROUP);
+		if (valid_element (info, STATE_RECENT_FILES,
+				   TAG_RECENT_ITEM, TAG_RECENT_FILES, error)) {
+			info->current_item = egg_recent_item_new ();
+			push_state (info, STATE_RECENT_ITEM);
+		}
+	} else if (ELEMENT_IS (TAG_URI)) {
+		if (valid_element (info, STATE_RECENT_ITEM,
+				   TAG_URI, TAG_RECENT_ITEM, error)) {
+			push_state (info, STATE_URI);
+		}
+	} else if (ELEMENT_IS (TAG_MIME_TYPE)) {
+		if (valid_element (info, STATE_RECENT_ITEM,
+				   TAG_MIME_TYPE, TAG_RECENT_ITEM, error)) {
+			push_state (info, STATE_MIME_TYPE);
+		}
+	} else if (ELEMENT_IS (TAG_TIMESTAMP)) {
+		if (valid_element (info, STATE_RECENT_ITEM,
+				   TAG_TIMESTAMP, TAG_RECENT_ITEM, error)) {
+			push_state (info, STATE_TIMESTAMP);
+		}
+	} else if (ELEMENT_IS (TAG_PRIVATE)) {
+		if (valid_element (info, STATE_RECENT_ITEM,
+				   TAG_PRIVATE, TAG_RECENT_ITEM, error)) {
+			push_state (info, STATE_PRIVATE);
+			egg_recent_item_set_private (info->current_item, TRUE);
+		}
+	} else if (ELEMENT_IS (TAG_GROUPS)) {
+		if (valid_element (info, STATE_RECENT_ITEM,
+				   TAG_GROUPS, TAG_RECENT_ITEM, error)) {
+			push_state (info, STATE_GROUPS);
+		}
+	} else if (ELEMENT_IS (TAG_GROUP)) {
+		if (valid_element (info, STATE_GROUPS,
+				   TAG_GROUP, TAG_GROUPS, error)) {
+			push_state (info, STATE_GROUP);
+		}
+	}
 }
 
 static gint
@@ -392,14 +458,22 @@
 
 	switch (peek_state (info)) {
 		case STATE_RECENT_ITEM:
-			info->items = g_list_append (info->items,
-						    info->current_item);
-			if (info->current_item->uri == NULL ||
-			    strlen (info->current_item->uri) == 0)
-				g_warning ("URI NOT LOADED");
-		break;
+			if (!info->current_item) {
+				g_warning ("No recent item found\n");
+				break;
+			}
+
+			if (!info->current_item->uri) {
+				g_warning ("Invalid item found\n");
+				break;
+			}
+				
+			info->items = g_list_prepend (info->items,
+			                              info->current_item);
+			info->current_item = NULL;
+			break;
 		default:
-		break;
+			break;
 	}
 
 	pop_state (info);
@@ -413,6 +487,9 @@
 		     GError **error)
 {
 	ParseInfo *info = (ParseInfo *)user_data;
+	gchar *value;
+
+	value = g_strndup (text, text_len);
 
 	switch (peek_state (info)) {
 		case STATE_START:
@@ -422,22 +499,22 @@
 		case STATE_GROUPS:
 		break;
 		case STATE_URI:
-			egg_recent_item_set_uri (info->current_item, text);
+			egg_recent_item_set_uri (info->current_item, value);
 		break;
 		case STATE_MIME_TYPE:
-			egg_recent_item_set_mime_type (info->current_item,
-							 text);
+			egg_recent_item_set_mime_type (info->current_item, value);
 		break;
 		case STATE_TIMESTAMP:
 			egg_recent_item_set_timestamp (info->current_item,
-							 (time_t)atoi (text));
+							 (time_t)atoi (value));
 		break;
 		case STATE_GROUP:
 			egg_recent_item_add_group (info->current_item,
 						     text);
 		break;
 	}
-			
+
+	g_free (value);
 }
 
 static void
@@ -511,23 +588,23 @@
 }
 
 static GList *
-egg_recent_model_filter (EggRecentModel *model,
-				GList *list)
+egg_recent_model_filter (EggRecentModel *model, GList *list)
 {
-	EggRecentItem *item;
 	GList *newlist = NULL;
+	GList *l;
 	gchar *mime_type;
 	gchar *uri;
 
 	g_return_val_if_fail (list != NULL, NULL);
 
-	while (list) {
+	for (l = list; l != NULL ; l = l->next) {
+		EggRecentItem *item = (EggRecentItem *) l->data;
 		gboolean pass_mime_test = FALSE;
 		gboolean pass_group_test = FALSE;
 		gboolean pass_scheme_test = FALSE;
-		item = (EggRecentItem *)list->data;
-		list = list->next;
 
+		g_assert (item != NULL);
+		
 		uri = egg_recent_item_get_uri (item);
 
 		/* filter by mime type */
@@ -570,17 +647,15 @@
 
 		if (pass_mime_test && pass_group_test && pass_scheme_test)
 			newlist = g_list_prepend (newlist, item);
+		else
+			egg_recent_item_unref (item);
 
 		g_free (uri);
 	}
 
-	if (newlist) {
-		newlist = g_list_reverse (newlist);
-		g_list_free (list);
-	}
+	g_list_free (list);
 
-	
-	return newlist;
+	return g_list_reverse (newlist);
 }
 
 
@@ -643,6 +718,8 @@
 static gboolean
 egg_recent_model_changed_timeout (EggRecentModel *model)
 {
+	model->priv->changed_timeout = 0;
+
 	egg_recent_model_changed (model);
 
 	return FALSE;
@@ -661,7 +738,9 @@
 	g_return_if_fail (EGG_IS_RECENT_MODEL (user_data));
 	model = EGG_RECENT_MODEL (user_data);
 
-	if (event_type == GNOME_VFS_MONITOR_EVENT_CHANGED) {
+	if (event_type == GNOME_VFS_MONITOR_EVENT_CHANGED ||
+	    event_type == GNOME_VFS_MONITOR_EVENT_CREATED ||
+	    event_type == GNOME_VFS_MONITOR_EVENT_DELETED) {
 		if (model->priv->changed_timeout > 0) {
 			g_source_remove (model->priv->changed_timeout);
 		}
@@ -673,25 +752,60 @@
 	}
 }
 
+static gboolean
+egg_recent_model_poll_timeout (gpointer user_data)
+{
+	EggRecentModel *model;
+	struct stat stat_buf;
+	int stat_res;
+
+	model = EGG_RECENT_MODEL (user_data);
+	stat_res = stat (model->priv->path, &stat_buf);
+
+	if (!stat_res && stat_buf.st_mtime &&  
+	    stat_buf.st_mtime != model->priv->last_mtime) {
+		model->priv->last_mtime = stat_buf.st_mtime;
+		
+		if (model->priv->changed_timeout > 0)
+			g_source_remove (model->priv->changed_timeout);
+		
+		model->priv->changed_timeout = g_timeout_add (
+			EGG_RECENT_MODEL_TIMEOUT_LENGTH,
+			(GSourceFunc)egg_recent_model_changed_timeout,
+			model);
+	}
+	return TRUE;
+}
+
 static void
 egg_recent_model_monitor (EggRecentModel *model, gboolean should_monitor)
 {
 	if (should_monitor && model->priv->monitor == NULL) {
 		char *uri;
+		GnomeVFSResult result;
 
 		uri = gnome_vfs_get_uri_from_local_path (model->priv->path);
 
-		gnome_vfs_monitor_add (&model->priv->monitor,
-				       uri,
-				       GNOME_VFS_MONITOR_FILE,
-				       egg_recent_model_monitor_cb,
-				       model);
+		result = gnome_vfs_monitor_add (&model->priv->monitor,
+				       		uri,
+				       		GNOME_VFS_MONITOR_FILE,
+				       		egg_recent_model_monitor_cb,
+				       		model);
 
 		g_free (uri);
 
 		/* if the above fails, don't worry about it.
 		 * local notifications will still happen
 		 */
+		if (result == GNOME_VFS_ERROR_NOT_SUPPORTED) {
+			if (model->priv->poll_timeout > 0)
+				g_source_remove (model->priv->poll_timeout);
+			
+			model->priv->poll_timeout = g_timeout_add (
+				EGG_RECENT_MODEL_POLL_TIME * 1000,
+				egg_recent_model_poll_timeout,
+				model);
+		}
 
 	} else if (!should_monitor && model->priv->monitor != NULL) {
 		gnome_vfs_monitor_cancel (model->priv->monitor);
@@ -718,7 +832,7 @@
 	GList *list=NULL;
 	gchar *content;
 	GMarkupParseContext *ctx;
-	ParseInfo info;
+	ParseInfo *info;
 	GError *error;
 
 	content = egg_recent_model_read_raw (model, file);
@@ -728,35 +842,39 @@
 		return NULL;
 	}
 
-	parse_info_init (&info);
+	info = parse_info_init ();
 	
-	ctx = g_markup_parse_context_new (&parser, 0, &info, NULL);
+	ctx = g_markup_parse_context_new (&parser, 0, info, NULL);
 	
 	error = NULL;
-	if (!g_markup_parse_context_parse (ctx, content, strlen (content),
-					   &error)) {
-		g_warning (error->message);
+	if (!g_markup_parse_context_parse (ctx, content, strlen (content), &error)) {
+		g_warning ("Error while parsing the .recently-used file: %s\n",
+			   error->message);
+		
 		g_error_free (error);
-		error = NULL;
-		goto out;
+		parse_info_free (info);
+
+		return NULL;
 	}
 
 	error = NULL;
-	if (!g_markup_parse_context_end_parse (ctx, &error))
-		goto out;
-	
-	g_markup_parse_context_free (ctx);
-out:
-	list = info.items;
+	if (!g_markup_parse_context_end_parse (ctx, &error)) {
+		g_warning ("Unable to complete parsing of the .recently-used file: %s\n",
+			   error->message);
+		
+		g_error_free (error);
+		g_markup_parse_context_free (ctx);
+		parse_info_free (info);
 
-	parse_info_free (&info);
+		return NULL;
+	}
+	
+	list = g_list_reverse (info->items);
 
+	g_markup_parse_context_free (ctx);
+	parse_info_free (info);
 	g_free (content);
 
-	/*
-	g_print ("Total items: %d\n", g_list_length (list));
-	*/
-
 	return list;
 }
 
@@ -859,13 +977,14 @@
 }
 
 static FILE *
-egg_recent_model_open_file (EggRecentModel *model)
+egg_recent_model_open_file (EggRecentModel *model,
+			    gboolean        for_writing)
 {
 	FILE *file;
 	mode_t prev_umask;
 	
 	file = fopen (model->priv->path, "r+");
-	if (file == NULL) {
+	if (file == NULL && for_writing) {
 		/* be paranoid */
 		prev_umask = umask (077);
 
@@ -882,6 +1001,7 @@
 static gboolean
 egg_recent_model_lock_file (FILE *file)
 {
+#ifdef HAVE_LOCKF
 	int fd;
 	gint	try = 5;
 
@@ -911,17 +1031,24 @@
 	}
 
 	return FALSE;
+#else
+	return TRUE;
+#endif /* HAVE_LOCKF */
 }
 
 static gboolean
 egg_recent_model_unlock_file (FILE *file)
 {
+#ifdef HAVE_LOCKF
 	int fd;
 
 	rewind (file);
 	fd = fileno (file);
 
 	return (lockf (fd, F_ULOCK, 0) == 0) ? TRUE : FALSE;
+#else
+	return TRUE;
+#endif /* HAVE_LOCKF */
 }
 
 static void
@@ -929,6 +1056,10 @@
 {
 	EggRecentModel *model = EGG_RECENT_MODEL (object);
 
+	if (model->priv->changed_timeout > 0) {
+		g_source_remove (model->priv->changed_timeout);
+	}
+
 	egg_recent_model_monitor (model, FALSE);
 
 
@@ -968,8 +1099,13 @@
 	g_hash_table_destroy (model->priv->monitors);
 	model->priv->monitors = NULL;
 
+	if (model->priv->poll_timeout > 0)
+		g_source_remove (model->priv->poll_timeout);
+	model->priv->poll_timeout =0;
 
 	g_free (model->priv);
+
+	parent_class->finalize (object);
 }
 
 static void
@@ -983,16 +1119,25 @@
 	switch (prop_id)
 	{
 		case PROP_MIME_FILTERS:
+			if (model->priv->mime_filter_values != NULL)
+				egg_recent_model_clear_mime_filter (model);
+			
 			model->priv->mime_filter_values =
 				(GSList *)g_value_get_pointer (value);
 		break;
 
 		case PROP_GROUP_FILTERS:
+			if (model->priv->group_filter_values != NULL)
+				egg_recent_model_clear_group_filter (model);
+			
 			model->priv->group_filter_values =
 				(GSList *)g_value_get_pointer (value);
 		break;
 
 		case PROP_SCHEME_FILTERS:
+			if (model->priv->scheme_filter_values != NULL)
+				egg_recent_model_clear_scheme_filter (model);
+			
 			model->priv->scheme_filter_values =
 				(GSList *)g_value_get_pointer (value);
 		break;
@@ -1053,6 +1198,10 @@
 {
 	GObjectClass *object_class;
 
+	parent_class = g_type_class_peek_parent (klass);
+
+	parent_class = g_type_class_peek_parent (klass);
+
 	object_class = G_OBJECT_CLASS (klass);
 	object_class->set_property = egg_recent_model_set_property;
 	object_class->get_property = egg_recent_model_get_property;
@@ -1203,6 +1352,8 @@
 					(GDestroyNotify) gnome_vfs_monitor_cancel);
 
 	model->priv->monitor = NULL;
+	model->priv->poll_timeout = 0;
+	model->priv->last_mtime = 0;
 	egg_recent_model_monitor (model, TRUE);
 }
 
@@ -1259,7 +1410,7 @@
 		g_free (uri);
 	}
 
-	file = egg_recent_model_open_file (model);
+	file = egg_recent_model_open_file (model, TRUE);
 	g_return_val_if_fail (file != NULL, FALSE);
 
 	time (&t);
@@ -1362,7 +1513,7 @@
 	g_return_val_if_fail (EGG_IS_RECENT_MODEL (model), FALSE);
 	g_return_val_if_fail (uri != NULL, FALSE);
 
-	file = egg_recent_model_open_file (model);
+	file = egg_recent_model_open_file (model, TRUE);
 	g_return_val_if_fail (file != NULL, FALSE);
 
 	if (egg_recent_model_lock_file (file)) {
@@ -1421,15 +1572,15 @@
 egg_recent_model_get_list (EggRecentModel *model)
 {
 	FILE *file;
-	GList *list=NULL;
+	GList *list = NULL;
 
-	file = egg_recent_model_open_file (model);
-	g_return_val_if_fail (file != NULL, NULL);
+	file = egg_recent_model_open_file (model, FALSE);
+	if (file == NULL)
+		return NULL;
 	
-	if (egg_recent_model_lock_file (file)) {
+	if (egg_recent_model_lock_file (file))
 		list = egg_recent_model_read (model, file);
-		
-	} else {
+	else {
 		g_warning ("Failed to lock:  %s", strerror (errno));
 		fclose (file);
 		return NULL;
@@ -1500,7 +1651,7 @@
 	FILE *file;
 	int fd;
 
-	file = egg_recent_model_open_file (model);
+	file = egg_recent_model_open_file (model, TRUE);
 	g_return_if_fail (file != NULL);
 
 	fd = fileno (file);
@@ -1516,8 +1667,27 @@
 		g_warning ("Failed to unlock: %s", strerror (errno));
 
 	fclose (file);
+	
+	if (model->priv->monitor == NULL) {
+		/* since monitoring isn't working, at least give a
+		 * local notification
+		 */
+		egg_recent_model_changed (model);
+	}
 }
 
+static void
+egg_recent_model_clear_mime_filter (EggRecentModel *model)
+{
+	g_return_if_fail (model != NULL);
+
+	if (model->priv->mime_filter_values != NULL) {
+		g_slist_foreach (model->priv->mime_filter_values,
+				 (GFunc) g_pattern_spec_free, NULL);
+		g_slist_free (model->priv->mime_filter_values);
+		model->priv->mime_filter_values = NULL;
+	}
+}	
 
 /**
  * egg_recent_model_set_filter_mime_types:
@@ -1537,12 +1707,7 @@
 
 	g_return_if_fail (model != NULL);
 
-	if (model->priv->mime_filter_values != NULL) {
-		g_slist_foreach (model->priv->mime_filter_values,
-				 (GFunc) g_pattern_spec_free, NULL);
-		g_slist_free (model->priv->mime_filter_values);
-		model->priv->mime_filter_values = NULL;
-	}
+	egg_recent_model_clear_mime_filter (model);
 
 	va_start (valist, model);
 
@@ -1559,6 +1724,18 @@
 	model->priv->mime_filter_values = list;
 }
 
+static void
+egg_recent_model_clear_group_filter (EggRecentModel *model)
+{
+	g_return_if_fail (model != NULL);
+
+	if (model->priv->group_filter_values != NULL) {
+		g_slist_foreach (model->priv->group_filter_values, (GFunc)g_free, NULL);
+		g_slist_free (model->priv->group_filter_values);
+		model->priv->group_filter_values = NULL;
+	}
+}
+
 /**
  * egg_recent_model_set_filter_groups:
  * @model:  A EggRecentModel object.
@@ -1577,12 +1754,8 @@
 
 	g_return_if_fail (model != NULL);
 
-	if (model->priv->group_filter_values != NULL) {
-		g_slist_foreach (model->priv->group_filter_values, (GFunc)g_free, NULL);
-		g_slist_free (model->priv->group_filter_values);
-		model->priv->group_filter_values = NULL;
-	}
-
+	egg_recent_model_clear_group_filter (model);
+	
 	va_start (valist, model);
 
 	str = va_arg (valist, gchar*);
@@ -1598,6 +1771,19 @@
 	model->priv->group_filter_values = list;
 }
 
+static void
+egg_recent_model_clear_scheme_filter (EggRecentModel *model)
+{
+	g_return_if_fail (model != NULL);
+
+	if (model->priv->scheme_filter_values != NULL) {
+		g_slist_foreach (model->priv->scheme_filter_values,
+				(GFunc) g_pattern_spec_free, NULL);
+		g_slist_free (model->priv->scheme_filter_values);
+		model->priv->scheme_filter_values = NULL;
+	}
+}
+
 /**
  * egg_recent_model_set_filter_uri_schemes:
  * @model:  A EggRecentModel object.
@@ -1615,13 +1801,8 @@
 
 	g_return_if_fail (model != NULL);
 
-	if (model->priv->scheme_filter_values != NULL) {
-		g_slist_foreach (model->priv->scheme_filter_values,
-				(GFunc) g_pattern_spec_free, NULL);
-		g_slist_free (model->priv->scheme_filter_values);
-		model->priv->scheme_filter_values = NULL;
-	}
-
+	egg_recent_model_clear_scheme_filter (model);
+	
 	va_start (valist, model);
 
 	str = va_arg (valist, gchar*);
@@ -1724,8 +1905,9 @@
 
 	g_return_if_fail (model != NULL);
 
-	file = egg_recent_model_open_file (model);
-	g_return_if_fail (file != NULL);
+	file = egg_recent_model_open_file (model, FALSE);
+	if (file == NULL)
+		return;
 	
 	if (egg_recent_model_lock_file (file)) {
 		list = egg_recent_model_read (model, file);
--- origsrc/planner-0.14.3/libplanner/Makefile.am	2008-02-14 13:22:55.000000000 -0600
+++ src/planner-0.14.3/libplanner/Makefile.am	2008-04-22 01:27:47.250000000 -0500
@@ -56,6 +56,7 @@
 	mrp-error.h				\
 	mrp-paths.h
 
+libplanner_1_la_LDFLAGS = -no-undefined
 libplanner_1_la_LIBADD = $(LIBPLANNER_LIBS)
 
 libplannerincludedir = $(includedir)/planner-1.0/libplanner
@@ -80,7 +81,7 @@
 	mrp-parser.c				\
 	mrp-parser.h
 
-libstorage_mrproject_1_la_LDFLAGS =  -avoid-version -module
+libstorage_mrproject_1_la_LDFLAGS =  -avoid-version -module -no-undefined
 libstorage_mrproject_1_la_LIBADD = libplanner-1.la
 
 if HAVE_GDA
@@ -90,7 +91,7 @@
 	mrp-sql.c				\
 	mrp-sql.h
 
-libstorage_sql_la_LDFLAGS =  -avoid-version -module
+libstorage_sql_la_LDFLAGS =  -avoid-version -module -no-undefined
 libstorage_sql_la_CFLAGS = $(GDA_CFLAGS) -DGDA_VERSION=@GDA_VER@
 libstorage_sql_la_LIBADD =  $(GDA_LIBS) libplanner-1.la
 endif
@@ -110,12 +111,12 @@
 	mrp-old-xml.h
 
 libmrp_xml_la_CFLAGS = -DDTDDIR=\""$(datadir)/planner/dtd"\"
-libmrp_xml_la_LDFLAGS = -avoid-version -module
+libmrp_xml_la_LDFLAGS = -avoid-version -module -no-undefined
 libmrp_xml_la_LIBADD = libplanner-1.la
 
 libmrp_xsl_la_SOURCES = mrp-xsl.c
 libmrp_xsl_la_CFLAGS = 	$(XSLT_CFLAGS) -DSTYLESHEETDIR=\""$(datadir)/planner/stylesheets"\"
-libmrp_xsl_la_LDFLAGS = -avoid-version -module
+libmrp_xsl_la_LDFLAGS = -avoid-version -module -no-undefined
 libmrp_xsl_la_LIBADD = $(XSLT_LIBS) libplanner-1.la
 
 mrp-marshal.h: Makefile.am mrp-marshal.list
--- origsrc/planner-0.14.3/libplanner-1.pc.in	2007-11-14 16:22:26.000000000 -0600
+++ src/planner-0.14.3/libplanner-1.pc.in	2008-04-22 01:34:39.593750000 -0500
@@ -7,6 +7,6 @@
 Description: Support library for Planner
 Requires: glib-2.0 gmodule-2.0 gobject-2.0 libxml-2.0 libgsf-1
 Version: @VERSION@
-Libs: -L${libdir} -lplanner-1
+Libs: -L${libdir} @PLANNER_IMPLIB@ -lplanner-1
 Cflags: -I${includedir}/planner-1.0
 
--- origsrc/planner-0.14.3/python/Makefile.am	2007-11-14 16:22:02.000000000 -0600
+++ src/planner-0.14.3/python/Makefile.am	2008-04-22 01:34:39.609375000 -0500
@@ -11,14 +11,14 @@
 pkgpyexec_LTLIBRARIES = planner.la plannerui.la
 
 planner_la_CFLAGS = -Wno-missing-declarations -Wno-missing-prototypes
-planner_la_LDFLAGS = -module -avoid-version -export-symbols-regex initplanner
-planner_la_LIBADD = $(LIBPLANNER_LIBS) $(top_builddir)/libplanner/libplanner-1.la
+planner_la_LDFLAGS = -module $(PLUGIN_LDFLAGS) -export-symbols-regex initplanner
+planner_la_LIBADD = $(LIBPLANNER_LIBS) $(top_builddir)/libplanner/libplanner-1.la $(PYTHON_LDFLAGS)
 planner_la_SOURCES = plannermodule.c
 nodist_planner_la_SOURCES = planner.c
 
 plannerui_la_CFLAGS = -Wno-missing-declarations -Wno-missing-prototypes
-plannerui_la_LDFLAGS = -module -avoid-version -export-symbols-regex initplannerui
-plannerui_la_LIBADD = $(PLANNER_LIBS) $(top_builddir)/libplanner/libplanner-1.la
+plannerui_la_LDFLAGS = -module $(PLUGIN_LDFLAGS) -export-symbols-regex initplannerui
+plannerui_la_LIBADD = $(PLANNER_LIBS) $(top_builddir)/libplanner/libplanner-1.la $(PYTHON_LDFLAGS)
 plannerui_la_SOURCES = planneruimodule.c
 nodist_plannerui_la_SOURCES = plannerui.c
 
--- origsrc/planner-0.14.3/src/Makefile.am	2008-02-14 13:22:55.000000000 -0600
+++ src/planner-0.14.3/src/Makefile.am	2008-04-22 01:56:27.031250000 -0500
@@ -153,11 +153,15 @@
 	planner-usage-tree.h
 
 planner_LDADD =				\
-	$(top_builddir)/libplanner/libplanner-1.la \
 	$(top_builddir)/libegg/recent-files/libeggrecent.la \
+	$(top_builddir)/libplanner/libplanner-1.la \
 	$(PLANNER_LIBS)
 
+if PLATFORM_WIN32
+planner_LDFLAGS = -Wl,--export-all-symbols,--out-implib,libplanner-plugin.a
+else
 planner_LDFLAGS = -export-dynamic
+endif
 
 #
 # Plugins
@@ -170,23 +174,26 @@
 libsql_plugin_la_SOURCES = planner-sql-plugin.c
 libsql_plugin_la_LIBADD =  $(GDA_LIBS)
 libsql_plugin_la_CFLAGS = $(GDA_CFLAGS) -DGDA_VERSION=@GDA_VER@
-libsql_plugin_la_LDFLAGS = -avoid-version -module
+libsql_plugin_la_LDFLAGS = $(PLUGIN_LDFLAGS)
+libsql_plugin_la_DEPENDENCIES = planner$(EXEEXT)
 endif
 
 if HAVE_PYTHON_PLUGIN
 python_plugin = libpython-plugin.la
 libpython_plugin_la_SOURCES = planner-python-plugin.c
-libpython_plugin_la_LDFLAGS = -avoid-version -module
+libpython_plugin_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 libpython_plugin_la_LIBADD  = $(PYTHON_LDFLAGS)
 libpython_plugin_la_CFLAGS  = $(PYGTK_CFLAGS)
+libpython_plugin_la_DEPENDENCIES = planner$(EXEEXT)
 endif
 
 if HAVE_EDS_PLUGIN
 eds_plugin = libeds-plugin.la
 libeds_plugin_la_SOURCES = planner-eds-plugin.c
-libeds_plugin_la_LDFLAGS = -avoid-version -module
+libeds_plugin_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 libeds_plugin_la_LIBADD  = $(EDS_LIBS)
 libeds_plugin_la_CFLAGS  = $(EDS_CFLAGS)
+libeds_plugin_la_DEPENDENCIES = planner$(EXEEXT)
 endif
 
 plugin_LTLIBRARIES = 			\
@@ -198,13 +205,18 @@
 	$(eds_plugin)
 
 libhtml_plugin_la_SOURCES = planner-html-plugin.c
-libhtml_plugin_la_LDFLAGS = -avoid-version -module
+libhtml_plugin_la_LDFLAGS = $(PLUGIN_LDFLAGS)
+libhtml_plugin_la_DEPENDENCIES = planner$(EXEEXT)
 
 libxmlplanner_plugin_la_SOURCES = planner-xml-planner-plugin.c
-libxmlplanner_plugin_la_LDFLAGS = -avoid-version -module
+libxmlplanner_plugin_la_LDFLAGS = $(PLUGIN_LDFLAGS)
+libxmlplanner_plugin_la_LIBADD = $(XSLT_LIBS)
+libxmlplanner_plugin_la_DEPENDENCIES = planner$(EXEEXT)
 
 libmsp_plugin_la_SOURCES = planner-msp-plugin.c
-libmsp_plugin_la_LDFLAGS = -avoid-version -module
+libmsp_plugin_la_LDFLAGS = $(PLUGIN_LDFLAGS)
+libmsp_plugin_la_LIBADD = $(XSLT_LIBS)
+libmsp_plugin_la_DEPENDENCIES = planner$(EXEEXT)
 
 planner-marshal.h: Makefile.am planner-marshal.list
 	$(GLIB_GENMARSHAL) --prefix=planner_marshal $(srcdir)/planner-marshal.list --header > xgen-gmh \
@@ -225,3 +237,9 @@
 EXTRA_DIST = planner-marshal.list
 
 CLEANFILES = $(built_sources)
+
+if PLATFORM_WIN32
+install-data-local:
+	$(mkinstalldirs) $(DESTDIR)$(libdir)
+	$(INSTALL_DATA) libplanner-plugin.a $(DESTDIR)$(libdir)
+endif
--- origsrc/planner-0.14.3/tests/Makefile.am	2007-11-14 16:22:22.000000000 -0600
+++ src/planner-0.14.3/tests/Makefile.am	2008-04-22 01:34:39.671875000 -0500
@@ -8,6 +8,7 @@
 	-DEXAMPLESDIR=\"$(top_srcdir)/tests/files\"
 
 LDADD =	\
+	libselfcheck.la	\
 	$(top_builddir)/libplanner/libplanner-1.la 	\
 	$(PLANNER_LIBS)
 
@@ -20,16 +21,12 @@
 noinst_PROGRAMS = scheduler-test time-test calendar-test task-test
 
 scheduler_test_SOURCES = scheduler-test.c
-scheduler_test_LDFLAGS = libselfcheck.la
 
 time_test_SOURCES = time-test.c
-time_test_LDFLAGS = libselfcheck.la
 
 calendar_test_SOURCES = calendar-test.c
-calendar_test_LDFLAGS = libselfcheck.la
 
 task_test_SOURCES = task-test.c
-task_test_LDFLAGS = libselfcheck.la
 
 # The loadable modules can't be found at distcheck time so disable the
 # tests for distcheck.
